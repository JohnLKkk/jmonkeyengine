#ifndef LPV_COMMON_GLSL
#define LPV_COMMON_GLSL

#define SH_C0 0.282094791f // 1 / 2sqrt(pi)
#define SH_C1 0.488602512f // sqrt(3/pi) / 2

/*Cosine lobe coeff*/
#define SH_cosLobe_C0 0.886226925f // sqrt(pi)/2
#define SH_cosLobe_C1 1.02332671f // sqrt(pi/3)

#define CELLSIZE 2.25

vec4 evalCosineLobeToDir(vec3 dir)
{
	return vec4( SH_cosLobe_C0, -SH_cosLobe_C1 * dir.y, SH_cosLobe_C1 * dir.z, -SH_cosLobe_C1 * dir.x );
}

// Get SH coeficients out of direction
vec4 dirToSH(vec3 dir)
{
    return vec4(SH_C0, -SH_C1 * dir.y, SH_C1 * dir.z, -SH_C1 * dir.x);
}

// Get gridcell as vector of floats
vec3 getGridCellf(vec3 world_space_position, int _max_grid_size)
{
	const vec3 center = vec3(0);
    vec3 max_grid_size = vec3(_max_grid_size);
	vec3 min = center - vec3(max_grid_size * 0.5 * CELLSIZE);
	return vec3((world_space_position - min) / CELLSIZE);
}

// Get gridcell as vector of ints
ivec3 getGridCelli(vec3 world_space_position, int max_grid_size)
{
	return ivec3(getGridCellf(world_space_position, max_grid_size));
}

#ifdef APPLY_LPV_GI
uniform int m_LpvGridSize;
uniform float m_IndirectLightAttenuation;
uniform sampler2D m_RedIndirectLight;
uniform sampler2D m_GreenIndirectLight;
uniform sampler2D m_BlueIndirectLight;

vec4 sample_grid_trilinear(in sampler2D t, vec3 grid_cell) {
	float f_grid_size = float(m_LpvGridSize);
	float zFloor = floor(grid_cell.z);

	vec2 tex_coord = vec2(grid_cell.x / (f_grid_size * f_grid_size) + zFloor / f_grid_size , grid_cell.y / f_grid_size);

	vec4 t1 = texture(t, tex_coord);
	vec4 t2 = texture(t, vec2(tex_coord.x + (1.0 / f_grid_size), tex_coord.y));

	return mix(t1,t2, grid_cell.z - zFloor);
}

vec3 get_lpv_intensity(in vec3 world_space_normal, in vec3 world_space_position)
{
	vec4 sh_intensity = dirToSH(-world_space_normal);
	vec3 grid_cell = getGridCellf(world_space_position.xyz, m_LpvGridSize);

	vec4 red_light = sample_grid_trilinear(m_RedIndirectLight, grid_cell);
	vec4 green_light = sample_grid_trilinear(m_GreenIndirectLight, grid_cell);
	vec4 blue_light = sample_grid_trilinear(m_BlueIndirectLight, grid_cell);

	// Dot with sh coeffiencients to get directioal light intesity from the normal
	return vec3(dot(sh_intensity, red_light), dot(sh_intensity, green_light), dot(sh_intensity, blue_light));
}
#endif

#endif // LPV_COMMON_GLSL
